#!/usr/bin/env python

from __future__ import print_function, unicode_literals, division

import sys
import os
import os.path
import signal
import copy
import argparse
import tempfile
import subprocess
from platform import node as hostname
from contextlib import contextmanager

import yaml

LIBVIRT_URI = "qemu:///system"
AVAILABLE = {
    'public': set(range(115, 124 + 1)),
    'private': set(range(2, 254 + 1))
}
HOST_NETWORKS = {
    'ceto': {
        'public':  ('br0', '52:54:01:00:00:{0:02X}', '164.39.7.{0:d}', "2a02:710:1000:700:5054:1ff:fe00:{0:02x}"),
        'pubpriv': ('br1', '52:54:01:01:01:{0:02X}', '10.0.1.{0:d}',   None),
        'private': ('br1', '52:54:01:01:03:{0:02X}', '10.0.3.{0:d}',   None)
    },
    'phorcys': {
        'public':  ('br0', '52:54:02:00:00:{0:02X}', '164.39.7.{0:d}', "2a02:710:1000:700:5054:2ff:fe00:{0:02x}"),
        'pubpriv': ('br1', '52:54:02:01:02:{0:02X}', '10.0.2.{0:d}',   None),
        'private': ('br1', '52:54:02:01:04:{0:02X}', '10.0.4.{0:d}',   None)
    }
}
HOST_CPUS = {"ceto": 4, "phorcys": 8}
HOST_IPS = {
    "ceto": {
        "public": ["164.39.7.113", "2a02:710:1000:700::71"],
        "pubpriv": ["10.0.1.113"]
    },
    "phorcys": {
        "public": ["164.39.7.114", "2a02:710:1000:700::72"],
        "pubpriv": ["10.0.2.114"]
    }
}
VM_BASE_SIZE = {"amt": 2, "unit": "G"}


def jinja_env():
    import jinja2
    jinja_dir = os.path.join(os.path.dirname(__file__), "templates")
    jinja_loader = jinja2.FileSystemLoader(jinja_dir)
    return jinja2.Environment(loader=jinja_loader, undefined=jinja2.StrictUndefined)


def available_addr_ids(db):
    networks = copy.deepcopy(AVAILABLE)

    for host in db.values():
        network, addr_id = host["ip"]
        networks[network].remove(addr_id)

    return networks

def allocate(db, host, vm_name, ram, vcpus, disk, network):
    if vm_name in db:
        raise ValueError("{0} already in database".format(vm_name))
    if vcpus > HOST_CPUS[host]:
        raise ValueError("{0} only has {1} cores".format(host, HOST_CPUS[host]))

    networks = available_addr_ids(db)
    available = networks[network]

    try:
        addr_id = available.pop()
    except KeyError:
        raise ValueError("Network {0} exhausted".format(network))

    db[vm_name] = {
        "host": host,
        "ram": ram,
        "vcpus": vcpus,
        "disk": disk,
        "ip": (network, addr_id)
    }

def expand_config(vm_name, vm):
    network, addr_id = vm["ip"]
    host_network_config = HOST_NETWORKS[vm["host"]]

    def interface(dev, ip_type):
        bridge, mac_template, ip_template, ip6_template = host_network_config[ip_type]
        return {
            "dev": dev,
            "bridge": bridge,
            "ip_type": ip_type,
            "mac": mac_template.format(addr_id),
            "ip": ip_template.format(addr_id),
            "ip6": ip6_template.format(addr_id) if ip6_template else None
        }

    if network == "public":
        interfaces = [interface(0, "pubpriv"), interface(1, "public")]
    elif network == "private":
        interfaces = [interface(0, "private")]
    else:
        assert False

    return {
        "host": vm["host"],
        "vm_name": vm_name,
        "ram": vm["ram"],
        "vcpus": vm["vcpus"],
        "disk": vm["disk"],
        "interfaces": interfaces
    }


def domain_xml(vm):
    template = jinja_env().get_template('domain.xml')
    return template.render(**vm)

def dnsmasq_dhcp(db, host):
    vms = [expand_config(name, cfg) for name, cfg in db.items()]
    template = jinja_env().get_template('dnsmasq-dhcp')
    return template.render(host=host, vms=vms)

def dnsmasq_hosts(db):
    ips = {}
    def add(ip, host):
        if ip is None:
            return
        ips.setdefault(ip, set())
        assert host not in ips[ip]
        ips[ip].add(host)

    for name, cfg in db.items():
        cfg = expand_config(name, cfg)
        for intf in cfg["interfaces"]:
            if intf["ip_type"] in {"private", "pubpriv"}:
                suffixes = ['.vm.habhub.org', '', '.private.vm.habhub.org']
            elif intf["ip_type"] == "public":
                suffixes = ['.vm.habhub.org', '', '.public.vm.habhub.org']
            else:
                assert False

            for s in suffixes:
                h = cfg["vm_name"] + s
                add(intf["ip"], h)
                add(intf["ip6"], h)

    for hostname, nets in HOST_IPS.items():
        for ip_type, addresses in nets.items():
            # note lack of .vm.
            if intf["ip_type"] in {"private", "pubpriv"}:
                suffixes = ['.habhub.org', '', '.private.habhub.org']
            elif intf["ip_type"] == "public":
                suffixes = ['.habhub.org', '', '.public.habhub.org']
            else:
                assert False

            for addr in addresses:
                for s in suffixes:
                    add(addr, hostname + s)

    fst = lambda (a, b): a
    ips = sorted(ips.items(), key=fst)

    line = lambda (ip, hosts): " ".join([ip] + sorted(hosts))
    lines = list(map(line, ips))
    return "\n".join(lines) + "\n"


def check_call(command):
    print(*command)
    subprocess.check_call(command)

def need_root():
    if os.getuid() != 0:
        raise OSError("Need root")

def need_habhub_host():
    if hostname() not in {"ceto", "phorcys"}:
        raise ValueError("Need to be run on ceto or phorcys", host)

def compare_disk_size(a, b):
    def normalise(x):
        if x["unit"] == "G":
            return x["amt"] * 1024  # lvm uses gibi
        else:
            assert x["unit"] == "M"
            return x["amt"]

    return normalise(a) - normalise(b)

def listAllDomains(conn):
    # wtf.
    return [conn.lookupByID(x).name() for x in conn.listDomainsID()] + conn.listDefinedDomains()


def create(db, conn, vm_name):
    need_root()
    import jinja2  # will need it below

    vm = expand_config(vm_name, db[vm_name])
    host = hostname()

    if host != vm["host"]:
        raise Exception("Must be run on {0}".format(vm["host"]))
    if vm_name in listAllDomains(conn):
        raise KeyError(vm_name + " already exists")

    assert host in {"ceto", "phorcys"}

    disk_cmp = compare_disk_size(VM_BASE_SIZE, vm["disk"])
    if disk_cmp > 0:
        raise Exception("Disk is not large enough")

    print("Defining", vm_name)
    domain = conn.defineXML(domain_xml(vm))

    lvcreate = [
        "lvcreate", "--quiet",
        vm["host"],
        "--name", "vm-{0}".format(vm_name),
        "--size", "{amt}{unit}".format(**vm["disk"])
    ]
    check_call(lvcreate)

    if disk_cmp == 0:
        dd = [
            "dd", "bs=1M",
            "if=/dev/{0}/vm-base".format(host),
            "of=/dev/{0}/vm-{1}".format(host, vm_name)
        ]
        check_call(dd)
    else:
        virt_resize = [
            "virt-resize", "-q",
            "--expand", "/dev/sda1",
            "/dev/{0}/vm-base".format(host),
            "/dev/{0}/vm-{1}".format(host, vm_name)
        ]
        check_call(virt_resize)

    print("Starting", vm_name)
    domain.setAutostart(True)
    domain.create()

def create_all(db, conn):
    existing = set(listAllDomains(conn))
    host = hostname()
    desired = set(vm_name for vm_name, vm in db.items() if vm["host"] == host)

    print("Existing:", *sorted(existing))
    print("Desired:", *sorted(desired))

    unknown = existing - desired
    if unknown:
        print("Warning: unrecognised VMs:", *sorted(unknown), file=sys.stderr)

    to_create = desired - existing
    print("To create:", *sorted(to_create))
    for vm_name in to_create:
        create(db, conn, vm_name)

def sync_dnsmasq(db):
    need_habhub_host()
    need_root()
    host = hostname()

    print("Writing hosts...")
    with open("/etc/dnsmasq/hosts", "w") as f:
        f.write(dnsmasq_hosts(db))

    print("Writing dhcp...")
    with open("/etc/dnsmasq/dhcp", "w") as f:
        f.write(dnsmasq_dhcp(db, host))

    with open("/run/dnsmasq/dnsmasq.pid") as f:
        pid = int(f.read())

    print("HUP dnsmasq ({0})".format(pid))
    os.kill(pid, signal.SIGHUP)


# records are (type : TXT | A | AAAA, name : string, target : string)

def public_record_to_string(type, name, target):
    limit = 40
    if len(target) > limit:
        target = target[:limit] + "..."
    return "{:4} {:30} {}".format(type, name, target)

def public_records(db):
    if hostname() == "support":
        with open("/etc/exim4/dkim.public.key") as f:
            dkim_public = f.read()
    else:
        dkim_public = subprocess.check_output(
            ["ssh", "support.vm.habhub.org", "cat", "/etc/exim4/dkim.public.key"]
        )

    dkim_public = dkim_public.splitlines()
    assert dkim_public[0] == "-----BEGIN PUBLIC KEY-----"
    assert dkim_public[-1] == "-----END PUBLIC KEY-----"
    dkim_public = "".join(dkim_public[1:-1])

    spf_record  = "v=spf1 a:support.vm.habhub.org -all"
    dkim_record = "v=DKIM1; p={}; t=s".format(dkim_public)

    for name, cfg in db.items():
        cfg = expand_config(name, cfg)

        yield "TXT", cfg["vm_name"], spf_record
        yield "TXT", "support._domainkey." + cfg["vm_name"], dkim_record

        for intf in cfg["interfaces"]:
            if intf["ip_type"] == "public":
                yield "A",    cfg["vm_name"], intf["ip"]
                yield "AAAA", cfg["vm_name"], intf["ip6"]

def sync_linode(records):
    # lazy import linode api so that we can run other things
    from linode.api import Api
    linode = Api(input("api key"))

    for d in linode.domain_list():
        if d["DOMAIN"] == "vm.habhub.org":
            vm_habhub_org = d["DOMAINID"]
            break
    else:
        raise ValueError("couldn't find vm.habhub.org")

    def radd(type, name, target):
        linode.domain_resource_create(
            DomainID=vm_habhub_org,
            Type=type,
            Name=name,
            Target=target
        )
    def rdelete(res):
        linode.domain_resource_delete(
            DomainID=vm_habhub_org,
            ResourceID=res["RESOURCEID"]
        )
    def rlist(): return linode.domain_resource_list(domainid=vm_habhub_org)

    def tuple_of_res(r): return (res["TYPE"].upper(), res["NAME"], res["TARGET"])
    rstr = public_record_to_string

    desired = set(records)

    for res in rlist():
        tup = tuple_of_res(res)
        if tup not in desired:
            print("Removing", rstr(*tup))
            rdelete(res)
        else:
            print("OK      ", rstr(*tup))
            desired.remove(tup)

    for tup in desired:
        print("Add     ", rstr(*tup))
        radd(*tup)


def read_db(filename):
    with open(filename, 'r') as f:
        db = yaml.safe_load(f)
        if db == None:
            return {}
        else:
            return db

@contextmanager
def change_db(filename):
    with open(filename, 'a+') as f:
        db = yaml.safe_load(f)
        if db == None:
            db = {}
        yield db
        f.truncate(0)
        yaml.safe_dump(db, f)


def cmd_allocate(args):
    with change_db(args.db) as db:
        allocate(db=db, host=args.host, vm_name=args.vm_name, ram=args.ram,
                        vcpus=args.vcpus, disk=args.disk, network=args.network)
        cfg = expand_config(args.vm_name, db[args.vm_name])
    yaml.safe_dump(cfg, sys.stdout)

def cmd_list(args):
    table = []
    db = read_db(args.db)

    for key in sorted(db.keys()):
        vm = expand_config(key, db[key])
        row = (vm["vm_name"], vm["host"])
        row += tuple(intf["ip"] for intf in vm["interfaces"])
        table.append(row)

    for row in table:
        print(*row, sep='\t')

def cmd_show(args):
    db = read_db(args.db)
    vm = expand_config(args.vm_name, db[args.vm_name])
    yaml.safe_dump(vm, sys.stdout)

def cmd_xml(args):
    db = read_db(args.db)
    vm = expand_config(args.vm_name, db[args.vm_name])
    print(domain_xml(vm))

def cmd_dnsmasq_dhcp(args):
    db = read_db(args.db)
    print(dnsmasq_dhcp(db, args.host), end='')

def cmd_dnsmasq_hosts(args):
    db = read_db(args.db)
    print(dnsmasq_hosts(db), end='')

def cmd_create(args):
    import libvirt
    db = read_db(args.db)
    need_habhub_host()
    conn = libvirt.open(LIBVIRT_URI)
    create(db, conn, args.vm_name)

def cmd_sync_dnsmasq(args):
    db = read_db(args.db)
    sync_dnsmasq(db)

def cmd_public_records(args):
    db = read_db(args.db)
    for r in public_records(db):
        print(public_record_to_string(*r))

def cmd_sync_linode(args):
    db = read_db(args.db)
    sync_linode(public_records(db))

def cmd_create_all(args):
    import libvirt
    db = read_db(args.db)
    need_habhub_host()
    sync_dnsmasq(db)
    conn = libvirt.open(LIBVIRT_URI)
    create_all(db, conn)


def main():
    def parse_amount_units(s, allowed_units):
        for u in allowed_units:
            if s.endswith(u):
                amt = int(s[:-len(u)])
                if amt <= 0:
                    raise ValueError(s)
                return {"unit": u, "amt": amt}
        else:
            raise ValueError(s)

    def ram(s): return parse_amount_units(s, {"GiB", "MiB"})
    def vcpus(s):
        n = int(s)
        if n < 0:
            raise ValueError(n)
        return n
    def disk(s): return parse_amount_units(s, {"G", "M"})


    parser = argparse.ArgumentParser()
    parser.add_argument("--db", help='VMs database', default="./vms.yaml")
    subparsers = parser.add_subparsers()

    allocate = subparsers.add_parser("allocate")
    allocate.set_defaults(func=cmd_allocate)
    allocate.add_argument("host", help='VM host', choices=HOST_NETWORKS.keys())
    allocate.add_argument("vm_name", help='guest hostname')
    allocate.add_argument('--ram', type=ram, help='RAM, with units MiB or GiB',
                          default={"unit": "GiB", "amt": 1})
    allocate.add_argument('--vcpus', type=vcpus, default=1)
    allocate.add_argument('--disk', type=disk, default="2G")
    allocate.add_argument('--public-ip', action='store_const', dest='network',
                          default='private', const='public')

    list = subparsers.add_parser("list")
    list.set_defaults(func=cmd_list)

    show = subparsers.add_parser("show")
    show.set_defaults(func=cmd_show)
    show.add_argument("vm_name", help='guest hostname')

    xml = subparsers.add_parser("xml", help='libvirt domain xml')
    xml.set_defaults(func=cmd_xml)
    xml.add_argument("vm_name", help='guest hostname')

    dnsmasq_dhcp = subparsers.add_parser("dnsmasq-dhcp", help='dnsmasq dhcp-hosts file')
    dnsmasq_dhcp.set_defaults(func=cmd_dnsmasq_dhcp)
    dnsmasq_dhcp.add_argument("host", help='VM host', choices=HOST_NETWORKS.keys())

    dnsmasq_hosts = subparsers.add_parser("dnsmasq-hosts", help='dnsmasq hosts file')
    dnsmasq_hosts.set_defaults(func=cmd_dnsmasq_hosts)

    create = subparsers.add_parser("create", help='create an allocate VM on this box')
    create.set_defaults(func=cmd_create)
    create.add_argument("vm_name", help='guest hostname')

    sync_dnsmasq = subparsers.add_parser("sync-dnsmasq", help='sync and HUP dnsmasq on this box')
    sync_dnsmasq.set_defaults(func=cmd_sync_dnsmasq)

    public_records = subparsers.add_parser("public-records", help='print public DNS records')
    public_records.set_defaults(func=cmd_public_records)

    sync_linode = subparsers.add_parser("sync-linode", help='sync linode public DNS')
    sync_linode.set_defaults(func=cmd_sync_linode)

    create_all = subparsers.add_parser("create-all", help="create VMs that should exist")
    create_all.set_defaults(func=cmd_create_all)

    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
